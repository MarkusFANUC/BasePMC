!!:--------------------------------------------------------------------------:
!!: File              : mode_{{PATH}}.src                                         :
!!: Creation date     : 29.11.2013                                           :
!!: Last modification : see table below                                      :
!!: Author            : FANUC FA Switzerland / Peter Bloesch                 :
!!: Description       : path specific mode decoding                          :
!!:--------------------------------------------------------------------------:
!!
!!:--------------------------------------------------------------------------:
!!:                     Modification                                         :
!!:--------------------------------------------------------------------------:
!!: Date   :Version: Sign  :Description                                      :
!!:--------------------------------------------------------------------------:
!!:01.09.14: 1.1.0 :Blp    :incsel was not set in case of                    :
!!:        :       :       :handwheel_support == 0 and pmc_type == 2 or      :
!!:        :       :       :pmc_type == 6 ; SETTCH added                     :
!!:--------------------------------------------------------------------------:
!!:02.06.20: 3.0.0 :Blp    :0i-D and 3xi-A removed                           :
!!:--------------------------------------------------------------------------:
!!:        :       :       :                                                 :
!!:--------------------------------------------------------------------------:
!!:        :       :       :                                                 :
!!:--------------------------------------------------------------------------:
!!:        :       :       :                                                 :
!!:--------------------------------------------------------------------------:
!!:        :       :       :                                                 :
!!:--------------------------------------------------------------------------:
!!:        :       :       :                                                 :
!!:--------------------------------------------------------------------------:

!! ===========================================================================
!! Code
!! ===========================================================================

!! ---------------------------------------------------------------------------
!! {{PATH}}: mode change enable
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: mode change enable
*)
#endif
                 RD        STL_{{PATH}}          ;"cycle start lamp signal"
#if ref_dir_1st_axis_{{PATH}} > -1
                 OR        REFRUN_{{PATH}}       ;"reference return active"
#endif
                 OR        RST_{{PATH}}          ;"resetting signal"
#if dcs_support == 1
   #if mcc_test == 1

                 OR        MCC_TEST             ;"mcc test running"
   #endif
   #if brake_test == 1
                 OR        BRK_TEST             ;"brake test active"
   #endif
#endif
                 WRT.NOT   MDCHEN_{{PATH}}       ;"mode change enable"

!! ---------------------------------------------------------------------------
!! {{PATH}}: automatic mode mem selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: automatic mode mem selection
*)
#endif
                 RD        K_MMEM_{{PATH}}       ;"key mode mem"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_MMEM               ;"key mode mem"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
#endif
                 OR        SETMEM_{{PATH}}       ;"force to mode mem"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_mmem_{{PATH}}       ;"memory mode mem"

                 RD        M_MEM_{{PATH}}        ;"mode mem selected"
                 WRT       L_MMEM_{{PATH}}       ;"led mode mem"

                 RD        M_MEM_{{PATH}}        ;"mode mem selected"
                 RST       SETMEM_{{PATH}}       ;"force to mode mem"

!! -----------------------------------------------
!! {{PATH}}: sub mode single block
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: sub mode single block
*)
#endif
                 RD        K_SBK_{{PATH}}        ;"key single block"
                 OR        SETSBK_{{PATH}}       ;"force to single block"
                 AND.NOT   mk_sbk_{{PATH}}       ;"memory key single block"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       reksbk_{{PATH}}       ;"re key single block"

                 RD        K_SBK_{{PATH}}        ;"key single block"
                 OR        SETSBK_{{PATH}}       ;"force to single block"
                 WRT       mk_sbk_{{PATH}}       ;"memory key single block"

                 RD        reksbk_{{PATH}}       ;"re key single block"
                 AND.NOT   SBK_{{PATH}}          ;"single block signal"
                 RD.STK    SBK_{{PATH}}          ;"single block signal"
                 AND.NOT   reksbk_{{PATH}}       ;"re key single block"
#if operatorspanel == 0 or soft_op_panel == 1
                 OR.STK
                 AND.NOT   SOP_RUN              ;"software op-panel active"
                 RD.STK    K_SBK_{{PATH}}        ;"key single block"
                 AND       SOP_RUN              ;"software op-panel active"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
#endif
                 OR.STK
#if nbr_of_path > 1
                 AND.NOT   PSYNREQ              ;"path synchronization request"
#endif
                 WRT       SBK_{{PATH}}          ;"single block signal"

                 RD        SETSBK_{{PATH}}       ;"force to single block"
                 RST       SETSBK_{{PATH}}       ;"force to single block"

                 RD        MSBK_{{PATH}}         ;"single block check signal"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       L_SBK_{{PATH}}        ;"led single block"

!! -----------------------------------------------
!! {{PATH}}: block skip
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: block skip
*)
#endif
                 RD        K_SKIP_{{PATH}}       ;"key block skip"
                 AND.NOT   mkskip_{{PATH}}       ;"memory key skip"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       rekskp_{{PATH}}       ;"rising edge key skip"

                 RD        K_SKIP_{{PATH}}       ;"key block skip"
                 WRT       mkskip_{{PATH}}       ;"memory key skip"

                 RD        rekskp_{{PATH}}       ;"rising edge key skip"
                 AND.NOT   BDT1_{{PATH}}         ;"skip block (bdt1)"
                 RD.STK    BDT1_{{PATH}}         ;"skip block (bdt1)"
                 AND.NOT   rekskp_{{PATH}}       ;"rising edge key skip"
#if operatorspanel == 0 or soft_op_panel == 1
                 OR.STK
                 AND.NOT   SOP_RUN              ;"software op-panel active"
                 RD.STK    K_SKIP_{{PATH}}       ;"key block skip"
                 AND       SOP_RUN              ;"software op-panel active"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
#endif
                 OR.STK
#if nbr_of_path > 1
                 AND.NOT   PSYNREQ          ;"path synchronization request"
#endif
                 WRT       BDT1_{{PATH}}         ;"skip block (bdt1)"

                 RD        MBDT1_{{PATH}}        ;"block skip btd1 check signal"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       L_SKIP_{{PATH}}       ;"led block skip"

!! -----------------------------------------------
!! {{PATH}}: optional stop M01
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: optional stop M01
*)
#endif
                 RD        K_OSTP_{{PATH}}       ;"key optional stop m01"
                 AND.NOT   mkostp_{{PATH}}       ;"memory key optional stop"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       rekosp_{{PATH}}       ;"re key optional stop"

                 RD        K_OSTP_{{PATH}}       ;"key optional stop m01"
                 WRT       mkostp_{{PATH}}       ;"memory key optional stop"

                 RD        rekosp_{{PATH}}       ;"re key optional stop"
                 AND.NOT   O_STOP_{{PATH}}       ;"optional stop m01 active"
                 RD.STK    O_STOP_{{PATH}}       ;"optional stop m01 active"
                 AND.NOT   rekosp_{{PATH}}       ;"re key optional stop"
#if operatorspanel == 0 or soft_op_panel == 1
                 OR.STK
                 AND.NOT   SOP_RUN              ;"software op-panel active"
                 RD.STK    K_OSTP_{{PATH}}       ;"key optional stop m01"
                 AND       SOP_RUN              ;"software op-panel active"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
#endif
                 OR.STK    
#if nbr_of_path > 1
                 AND.NOT   PSYNREQ              ;"path synchronization request"
#endif
                 WRT       O_STOP_{{PATH}}       ;"optional stop m01 active"

                 RD        O_STOP_{{PATH}}       ;"optional stop m01 active"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       L_OSTP_{{PATH}}       ;"led optional stop m01"


!! -----------------------------------------------
!! {{PATH}}: program restart
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: program restart
*)
#endif
                 RD        K_REST_{{PATH}}       ;"key program restart"
                 AND.NOT   mkrest_{{PATH}}       ;"mem key program restart"
                 AND.NOT   STL_{{PATH}}          ;"cycle start lamp signal"
                 WRT       re_krest_{{PATH}}     ;"re program restart"

                 RD        K_REST_{{PATH}}       ;"key program restart"
                 WRT       mkrest_{{PATH}}       ;"mem key program restart"

                 RD        re_krest_{{PATH}}     ;"re program restart"
                 AND.NOT   SRN_{{PATH}}          ;"program restart signal"
                 RD.STK    SRN_{{PATH}}          ;"program restart signal"
                 AND.NOT   re_krest_{{PATH}}     ;"re program restart"
                 OR.STK    
                 AND       M_MEM_{{PATH}}        ;"mode mem selected"
                 WRT       SRN_{{PATH}}          ;"program restart signal"

                 RD        SRN_{{PATH}}          ;"program restart signal"
                 WRT       L_REST_{{PATH}}       ;"led program restart"


!! -----------------------------------------------
!! {{PATH}}: machine lock (testing a program)
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: machine lock (testing a program)
*)
#endif
                 RD        K_PGMT_{{PATH}}       ;"key program test"
                 AND.NOT   mkpgmt_{{PATH}}       ;"memory key program test"
                 AND.NOT   STL_{{PATH}}          ;"cycle start lamp signal"
                 WRT       repgmt_{{PATH}}       ;"rising edge key pgm test"

                 RD        K_PGMT_{{PATH}}       ;"key program test"
                 WRT       mkpgmt_{{PATH}}       ;"memory key program test"

                 RD        repgmt_{{PATH}}       ;"rising edge key pgm test"
                 AND.NOT   MLK_{{PATH}}          ;"all axis machine lock"
                 RD.STK.NOT repgmt_{{PATH}}      ;"rising edge key pgm test"
                 AND       MLK_{{PATH}}          ;"all axis machine lock"
#if operatorspanel == 0 or soft_op_panel == 1
                 OR.STK
                 AND.NOT   SOP_RUN              ;"software op-panel active"
                 RD.STK.NOT MLK_{{PATH}}         ;"all axis machine lock"
                 AND.NOT   STL_{{PATH}}          ;"cycle start lamp signal"
                 OR        MLK_{{PATH}}          ;"all axis machine lock"
                 RD.STK    K_PGMT_{{PATH}}       ;"key program test"
                 RD.STK    MLK_{{PATH}}          ;"all axis machine lock"
                 AND       STL_{{PATH}}          ;"cycle start lamp signal"
                 OR.STK    
                 AND.STK   
                 AND       SOP_RUN              ;"software op-panel active"
#endif
                 OR.STK
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
#if nbr_of_path > 1
                 AND.NOT   PSYNREQ              ;"path synchronization request"
#endif
                 WRT       MLK_{{PATH}}          ;"all axis machine lock"
                 WRT       AFL_{{PATH}}          ;"auxiliary function lock"

                 RD.NOT    MLK_{{PATH}}          ;"all axis machine lock"
                 AND       m_pgmt_{{PATH}}       ;"memory program test"
                 WRT       FEPGMT_{{PATH}}       ;"falling edge program test"

                 RD        MLK_{{PATH}}          ;"all axis machine lock"
                 WRT       m_pgmt_{{PATH}}       ;"memory program test"

                 RD        MMLK_{{PATH}}         ;"all axis lock check signal"
                 AND       MAFL_{{PATH}}         ;"aux. function lock check signal"
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
                 WRT       L_PGMT_{{PATH}}       ;"led program test"


!! -----------------------------------------------
!! {{PATH}}: dry run
!! (Only active in mode mem)
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: dry run
(only active in mode mem)
*)
#endif
                 RD        K_DRN_{{PATH}}        ;"key dry run"
                 AND.NOT   mk_drn_{{PATH}}       ;"memory key dry run"
                 WRT       rekdrn_{{PATH}}       ;"rising edge key dry run"

                 RD        K_DRN_{{PATH}}        ;"key dry run"
                 WRT       mk_drn_{{PATH}}       ;"memory key dry run"

                 RD        rekdrn_{{PATH}}       ;"rising edge key dry run"
                 AND.NOT   STL_{{PATH}}          ;"cycle start lamp signal"
                 AND.NOT   DRN_{{PATH}}          ;"dry run signal"
                 RD.STK    DRN_{{PATH}}          ;"dry run signal"
                 AND.NOT   rekdrn_{{PATH}}       ;"rising edge key dry run"
#if operatorspanel == 0 or soft_op_panel == 1
                 OR.STK
                 AND.NOT   SOP_RUN              ;"software op-panel active"
                 RD.STK.NOT DRN_{{PATH}}         ;"dry run signal"
                 AND.NOT   STL_{{PATH}}          ;"cycle start lamp signal"
                 OR        DRN_{{PATH}}          ;"dry run signal"
                 AND       K_DRN_{{PATH}}        ;"key dry run"
                 AND       SOP_RUN              ;"software op-panel active"
#endif
                 OR.STK
                 AND       M_AUTO_{{PATH}}       ;"automatic mode active"
#if nbr_of_path > 1
                 AND.NOT   PSYNREQ              ;"path synchronization request"
#endif
                 WRT       DRN_{{PATH}}          ;"dry run signal"

                 RD        MDRN_{{PATH}}         ;"dry run check signal"
                 WRT       L_DRN_{{PATH}}        ;"led dry run"


!! ---------------------------------------------------------------------------
!! {{PATH}}: edit mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: edit mode selection
*)
#endif
                 RD        K_MEDT_{{PATH}}       ;"key mode edit"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_MEDT               ;"key mode edit"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
#endif
                 OR        SETEDT_{{PATH}}       ;"force to mode edit"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_medt_{{PATH}}       ;"memory mode edit"

                 RD        M_EDT_{{PATH}}        ;"mode edit selected"
                 WRT       L_MEDT_{{PATH}}       ;"led mode edit"

                 RD        M_EDT_{{PATH}}        ;"mode edit selected"
                 RST       SETEDT_{{PATH}}       ;"force to mode edit"

!! ---------------------------------------------------------------------------
!! {{PATH}}: mdi mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: mdi mode selection
*)
#endif
                 RD        K_MMDI_{{PATH}}       ;"key mode mdi"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_MMDI               ;"key mode mdi"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK    
#endif
                 OR        SETMDI_{{PATH}}       ;"force to mode mdi"
#if ref_dir_1st_axis_{{PATH}} == -1
                 OR.NOT    FICYCL               ;"first cycle finished"
#endif
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_mmdi_{{PATH}}       ;"memory mode mdi"

                 RD        M_MDI_{{PATH}}        ;"mode mdi selected"
                 WRT       L_MMDI_{{PATH}}       ;"led mode mdi"

                 RD        M_MDI_{{PATH}}        ;"mode mdi selected"
                 RST       SETMDI_{{PATH}}       ;"force to mode mdi"

!! ---------------------------------------------------------------------------
!! {{PATH}}: dnc operation mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: dnc operation mode selection
*)
#endif
                 RD        K_DNC_{{PATH}}        ;"key dnc operation mode"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_DNC                ;"key dnc operation mode"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK    
#endif
                 OR        SETDNC_{{PATH}}       ;"force to dnc operation"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mdnc_{{PATH}}       ;"memory dnc mode"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_mdnc_{{PATH}}       ;"memory dnc mode"

                 RD        M_DNC_{{PATH}}        ;"mode dnc selected"
                 WRT       L_DNC_{{PATH}}        ;"led dnc operation"

                 RD        M_DNC_{{PATH}}        ;"mode dnc selected"
                 RST       SETDNC_{{PATH}}       ;"force to dnc operation"

!! ---------------------------------------------------------------------------
!! {{PATH}}: jog mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: jog mode selection
*)
#endif
                 RD        K_MJ_{{PATH}}         ;"key mode jog"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_MJ                 ;"key mode jog"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
#endif
                 OR        SETJOG_{{PATH}}       ;"force to mode jog"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_mj_{{PATH}}         ;"memory mode jog"

                 RD        M_JOG_{{PATH}}        ;"mode jog selected"
                 WRT       L_MJ_{{PATH}}         ;"led mode jog"

                 RD        M_JOG_{{PATH}}        ;"mode jog selected"
                 RST       SETJOG_{{PATH}}       ;"force to mode jog"

!! ---------------------------------------------------------------------------
!! {{PATH}}: ref mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: ref mode selection
*)
#endif
#if ref_dir_1st_axis_{{PATH}} > -1
                 RD        K_MREF_{{PATH}}       ;"key mode ref"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_MREF               ;"key mode ref"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
#endif
                 OR        SETREF_{{PATH}}       ;"force mode ref"
                 OR.NOT    FICYCL               ;"first cycle finished"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mref_{{PATH}}       ;"memory mode ref"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_mhdi_{{PATH}}       ;"memory mode handle"
                 OR.STK
                 WRT       m_mref_{{PATH}}       ;"memory mode ref"

                 RD        M_REF_{{PATH}}        ;"mode ref selected"
                 WRT       L_MREF_{{PATH}}       ;"led mode ref"
#endif

#if ref_dir_1st_axis_{{PATH}} > -1
                 RD        M_REF_{{PATH}}        ;"mode ref selected"
#else
                 RD        LOG1                 ;"logic one"
#endif
                 RST       SETREF_{{PATH}}       ;"force mode ref"

!! ---------------------------------------------------------------------------
!! {{PATH}}: handle/incremental feed mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: handle/incremental feed mode selection
*)
#endif
                 RD        K_INC_{{PATH}}        ;"key inc feed"
#if handwheel_support > 0
                 OR        K_HD_{{PATH}}         ;"key handle"
#endif
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
#endif
#if handwheel_support > 0
                 OR        SET_HD_{{PATH}}       ;"force to mode handle"
#endif
   #if nbr_of_path > 1
                 RD.STK    K_INC                ;"key inc feed"
#if handwheel_support > 0
                 OR        K_HD                 ;"key handle"
#endif
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
   #endif
                 OR        SETINC_{{PATH}}       ;"force to mode inc feed"
                 AND       MDCHEN_{{PATH}}       ;"mode change enable"
                 RD.STK    m_mhdi_{{PATH}}       ;"memory mode handle"
                 AND.NOT   m_mmem_{{PATH}}       ;"memory mode mem"
                 AND.NOT   m_medt_{{PATH}}       ;"memory mode edit"
                 AND.NOT   m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND.NOT   m_mdnc_{{PATH}}       ;"memory dnc mode"
                 AND.NOT   m_mj_{{PATH}}         ;"memory mode jog"
#if ref_dir_1st_axis_{{PATH}} > -1
                 AND.NOT   m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 OR.STK
                 WRT       m_mhdi_{{PATH}}       ;"memory mode handle"

!! -----------------------------------------------
!! {{PATH}}: handle mode selection
!! -----------------------------------------------
#if handwheel_support > 0
#if net_comment == 1
(*
{{PATH}}: handle mode selection
*)
#endif
                 RD        K_HD_{{PATH}}         ;"key handle"
#if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_HD                 ;"key handle"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
#endif
                 OR        SET_HD_{{PATH}}       ;"force to mode handle"
                 RD.STK    hdsel_{{PATH}}        ;"handle selected"
                 AND.NOT   incsel_{{PATH}}       ;"inc selected"
                 OR.STK
                 AND       m_mhdi_{{PATH}}       ;"memory mode handle"
                 WRT       hdsel_{{PATH}}        ;"handle selected"

                 RD        M_HD_{{PATH}}         ;"mode handle selected"
                 WRT       L_HD_{{PATH}}         ;"led mode handle"

                 RD        M_HD_{{PATH}}         ;"mode handle selected"
                 RST       SET_HD_{{PATH}}       ;"force to mode handle"
#endif

!! -----------------------------------------------
!! {{PATH}}: inc feed mode selection
!! -----------------------------------------------
#if net_comment == 1
(*
{{PATH}}: inc feed mode selection
*)
#endif
#if handwheel_support > 0 or pmc_type < 3
                 RD        K_INC_{{PATH}}        ;"key inc feed"
   #if nbr_of_path > 1
                 AND.NOT   PATHSYN              ;"Path syncronization signal"
                 RD.STK    K_INC                ;"key inc feed"
                 AND       PATHSYN              ;"Path syncronization signal"
                 OR.STK
   #endif
                 OR        SETINC_{{PATH}}       ;"force to mode inc feed"
                 RD.STK    incsel_{{PATH}}       ;"inc selected"
   #if handwheel_support > 0
                 AND.NOT   hdsel_{{PATH}}        ;"handle selected"
   #endif
                 OR.STK
                 AND       m_mhdi_{{PATH}}       ;"memory mode handle"
                 WRT       incsel_{{PATH}}       ;"inc selected"
#endif
                 RD        M_INC_{{PATH}}        ;"memory mode inc"
                 WRT       L_INC_{{PATH}}        ;"led mode inc"

                 RD        M_INC_{{PATH}}        ;"memory mode inc"
                 RST       SETINC_{{PATH}}       ;"force to mode inc feed"

!! ---------------------------------------------------------------------------
!! {{PATH}}: teach in mode selection
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: teach in mode selection
*)
#endif
                 RD        K_TEACH_{{PATH}}      ;"key teach in"
                 AND       M_MAN_{{PATH}}        ;"manual mode active"
                 AND.NOT   M_REF_{{PATH}}        ;"mode REF selected"
                 AND.NOT   mkteach_{{PATH}}      ;"mem key teach in"
                 WRT       rekteach_{{PATH}}     ;"re key teach in"

                 RD        K_TEACH_{{PATH}}      ;"key teach in"
                 AND       M_MAN_{{PATH}}        ;"manual mode active"
                 AND.NOT   M_REF_{{PATH}}        ;"mode REF selected"
                 WRT       mkteach_{{PATH}}      ;"mem key teach in"

                 RD        rekteach_{{PATH}}     ;"re key teach in"
                 OR        SETTCH_{{PATH}}       ;"force teach in"
                 AND.NOT   m_tchin_{{PATH}}      ;"memory mode teach in"
                 RD.STK    m_tchin_{{PATH}}      ;"memory mode teach in"
                 AND.NOT   rekteach_{{PATH}}     ;"re key teach in"
                 OR.STK    
                 WRT       m_tchin_{{PATH}}      ;"memory mode teach in"

                 RD        M_TEACH_{{PATH}}      ;"mode TEACH IN selected"
                 WRT       L_TEACH_{{PATH}}      ;"led teach in mode"
                 RST       SETTCH_{{PATH}}       ;"force teach in"

!! ---------------------------------------------------------------------------
!! {{PATH}}: mode selection signals
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: mode selection signals
*)
#endif
                 RD        m_mmem_{{PATH}}       ;"memory mode mem"
                 OR        m_medt_{{PATH}}       ;"memory mode edit"
                 RD.STK    m_mj_{{PATH}}         ;"memory mode jog"
                 AND.NOT   m_tchin_{{PATH}}      ;"memory mode teach in"
                 OR.STK    
                 RD.STK    m_mhdi_{{PATH}}       ;"memory mode handle / inc"
                 AND       m_tchin_{{PATH}}      ;"memory mode teach in"
                 OR.STK    
                 OR        m_mdnc_{{PATH}}       ;"memory dnc mode"
#if ref_dir_1st_axis_{{PATH}} > -1
                 OR        m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 WRT       MD1_{{PATH}}          ;"mode selection signal 1"

                 RD        m_medt_{{PATH}}       ;"memory mode edit"
                 RD.STK    m_mj_{{PATH}}         ;"memory mode jog"
                 OR        m_mhdi_{{PATH}}       ;"memory mode handle / inc"
                 AND       m_tchin_{{PATH}}      ;"memory mode teach in"
                 OR.STK    
                 WRT       MD2_{{PATH}}          ;"mode selection signal 2"

                 RD        m_mj_{{PATH}}         ;"memory mode jog"
#if ref_dir_1st_axis_{{PATH}} > -1
                 OR        m_mref_{{PATH}}       ;"memory mode ref"
#endif
                 OR        m_mhdi_{{PATH}}       ;"memory mode handle"
                 WRT       MD4_{{PATH}}          ;"mode selection signal 4"

                 RD        m_mdnc_{{PATH}}       ;"memory dnc mode"
                 WRT       DNCI_{{PATH}}         ;"dnc selection signal"

#if ref_dir_1st_axis_{{PATH}} > -1
                 RD        m_mref_{{PATH}}       ;"memory mode ref"
                 AND.NOT   D_REFx_{{PATH}}       ;"ref return without dog"
                 WRT       ZRN_{{PATH}}          ;"man. ref. pos. selection sign."
#endif

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_MEM_{{PATH}} (mode mem selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_MEM_{{PATH}} (mode mem selected)
*)
#endif
                 RD        m_mmem_{{PATH}}       ;"memory mode mem"
                 AND       MMEM_{{PATH}}         ;"mode memory operation"
                 WRT       M_MEM_{{PATH}}        ;"mode mem selected"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_EDT_{{PATH}} (mode edit selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_EDT_{{PATH}} (mode edit selected)
*)
#endif
                 RD        m_medt_{{PATH}}       ;"memory mode edit"
                 AND       MEDT_{{PATH}}         ;"mode edit"
                 WRT       M_EDT_{{PATH}}        ;"mode edit selected"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_MDI_{{PATH}} (mode mdi selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_MDI_{{PATH}} (mode mdi selected)
*)
#endif
                 RD        m_mmdi_{{PATH}}       ;"memory mode mdi"
                 AND       MMDI_{{PATH}}         ;"mode mdi selected"
                 WRT       M_MDI_{{PATH}}        ;"mode mdi selected"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_DNC_{{PATH}} (mode dnc selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_DNC_{{PATH}} (mode dnc selected)
*)
#endif
                 RD        m_mdnc_{{PATH}}       ;"memory dnc mode"
                 AND       MRMT_{{PATH}}         ;"dnc operation"
                 WRT       M_DNC_{{PATH}}        ;"mode dnc selected"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_JOG_{{PATH}} (jog mode active)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_JOG_{{PATH}} (jog mode active)
*)
#endif
                 RD        m_mj_{{PATH}}         ;"memory mode jog"
                 AND       MJ_{{PATH}}           ;"jog feed select check signal"
                 WRT       M_JOG_{{PATH}}        ;"mode jog selected"

#if ref_dir_1st_axis_{{PATH}} > -1
!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable D_JOGMV (delay jog move)
!! ---------------------------------------------------------------------------
   #if net_comment == 1
(*
{{PATH}}:  global variable D_JOGMV (delay jog move)
*)
   #endif
                 RD        M_REFJ_{{PATH}}       ;"jog mode during ref"
                 AND.NOT   ZRN_{{PATH}}          ;"ref. pos. select sign."
                 RD.STK    MREF_{{PATH}}         ;"mode manual ref. return"
                 AND.NOT   D_REFx_{{PATH}}       ;"ref return without dog"
                 OR.STK    
                 TMRB      
                           0
                           48
                 WRT       D_JOGMV_{{PATH}}      ;"delay jog move"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_REFJ (jog mode during ref return)
!! ---------------------------------------------------------------------------
   #if net_comment == 1
(*
{{PATH}}: global variable M_REFJ (jog mode during ref return)
*)
   #endif
                 RD        D_REFx_{{PATH}}       ;"Ref return without dog"
                 RD.STK    mdrefx_{{PATH}}       ;"memory ref without dog"
                 AND.NOT   MREF_{{PATH}}         ;"mode manual ref. return"
                 OR.STK    
                 AND.NOT   REFSTP_{{PATH}}       ;"stop reference return"
                 WRT       mdrefx_{{PATH}}       ;"memory ref without dog"

                 RD        mdrefx_{{PATH}}       ;"memory ref without dog"
                 AND       MJ_{{PATH}}           ;"jog feed sel. check signal"
                 WRT       M_REFJ_{{PATH}}       ;"jog mode during ref"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_REF_{{PATH}} (ref mode selected)
!! ---------------------------------------------------------------------------
   #if net_comment == 1
(*
{{PATH}}: global variable M_REF_{{PATH}} (ref mode selected)
*)
   #endif
                 RD        MREF_{{PATH}}         ;"mode manual ref. return"
                 OR        mdrefx_{{PATH}}       ;"memory ref without dog"
                 AND       m_mref_{{PATH}}       ;"memory mode ref"
                 WRT       M_REF_{{PATH}}        ;"mode REF selected"
#endif

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_HD_{{PATH}} (handle mode selected)
!! ---------------------------------------------------------------------------
#if handwheel_support >0
   #if net_comment == 1
(*
{{PATH}}: global variable M_HD_{{PATH}} (handle mode selected)
*)
   #endif
                 RD        hdsel_{{PATH}}        ;"handle selected"
                 AND       MH_{{PATH}}           ;"mode handle"
                 WRT       M_HD_{{PATH}}         ;"mode handle selected"
#endif

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable  M_INC_{{PATH}} (inc feed mode selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable  M_INC_{{PATH}} (inc feed mode selected)
*)
#endif
                 RD        MINC_{{PATH}}         ;"mode incremental feed"
#if handwheel_support > 0 or pmc_type < 3
                 OR        MH_{{PATH}}           ;"mode handle"
                 AND       incsel_{{PATH}}       ;"inc selected"
#else
                 OR        MH_{{PATH}}           ;"mode handle"
                 AND       m_mhdi_{{PATH}}       ;"memory mode handle"
#endif
                 WRT       M_INC_{{PATH}}        ;"mode INC selected"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable  M_TEACH_{{PATH}} (mode TEACH IN selected)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_TEACH (teach in mode selected)
*)
#endif
                 RD        m_tchin_{{PATH}}      ;"memory mode teach in"
                 AND       MTCHIN_{{PATH}}       ;"teach in sel. check signal"
                 WRT       M_TEACH_{{PATH}}      ;"mode TEACH IN selected"


!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_AUTO_{{PATH}} (automatic mode active)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_AUTO_{{PATH}} (automatic mode active)
*)
#endif
                 RD        M_MDI_{{PATH}}        ;"mode mdi selected"
                 OR        M_MEM_{{PATH}}        ;"mode mem selected"
                 OR        M_DNC_{{PATH}}        ;"mode dnc selected"
                 WRT       M_AUTO_{{PATH}}       ;"automatic mode active"

!! ---------------------------------------------------------------------------
!! {{PATH}}: global variable M_MAN_{{PATH}} (manual mode active)
!! ---------------------------------------------------------------------------
#if net_comment == 1
(*
{{PATH}}: global variable M_MAN_{{PATH}} (manual mode active)
*)
#endif
                 RD        M_INC_{{PATH}}        ;"mode inc selected"
#if handwheel_support > 0
                 OR        M_HD_{{PATH}}         ;"mode handle selected"
#endif
                 OR        M_JOG_{{PATH}}        ;"mode jog selected"
#if ref_dir_1st_axis_{{PATH}} > -1
                 OR        M_REF_{{PATH}}        ;"mode ref selected"
#endif
                 WRT       M_MAN_{{PATH}}        ;"manual mode active"
